<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR AR Breakout Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px;
            z-index: 100;
        }
        #startARButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            font-size: 18px;
            background-color: #4285f4;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #gameOverScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 200;
        }
        #gameOverScreen button {
            margin-top: 15px;
            padding: 10px 20px;
            background-color: #4285f4;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #scoreDisplay {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #notSupportedInfo {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 300;
            max-width: 80%;
        }
    </style>
</head>
<body>
    <div id="info">WebXR AR Breakout Game<br/>Use Meta Quest 3 controllers to move the paddle and hit the ball</div>
    <div id="scoreDisplay">Score: 0 | Lives: 3</div>
    <button id="startARButton">Start AR Game</button>
    
    <div id="gameOverScreen">
        <h2>Game Over</h2>
        <p id="finalScore">Your score: 0</p>
        <button id="restartButton">Play Again</button>
        <button id="exitARButton">Exit AR</button>
    </div>
    
    <div id="notSupportedInfo">
        <h2>WebXR Not Supported</h2>
        <p>Your browser or device does not support WebXR or AR features required for this game.</p>
        <p>Please try using a WebXR-compatible browser on a supported device like Meta Quest 3.</p>
    </div>

    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.module.js';
        import { BoxLineGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/geometries/BoxLineGeometry.js';
        import { XRControllerModelFactory } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/XRControllerModelFactory.js';
        
        // FIX 1: Import ARButton with correct path and create our own implementation
        // import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/ARButton.js';

        // Game variables
        let container;
        let scene, camera, renderer;
        let controller1, controller2, controllerGrip1, controllerGrip2;
        let paddle;
        let ball;
        let bricks = [];
        let gameActive = false;
        let gameStarted = false;
        let score = 0;
        let lives = 3;
        let ballSpeed = 0.05;
        let ballDirection = new THREE.Vector3(0.03, 0.04, 0);
        let raycaster = new THREE.Raycaster();
        let tempMatrix = new THREE.Matrix4();
        let gameBoard;
        let clock = new THREE.Clock();
        let currentSession = null;
        let hitTestSource = null;
        let hitTestSourceRequested = false;
        let placementIndicator;
        let isGamePlaced = false;
        
        // Constants
        const PADDLE_WIDTH = 0.2;
        const PADDLE_HEIGHT = 0.03;
        const PADDLE_DEPTH = 0.04;
        const BALL_RADIUS = 0.02;
        const BRICK_WIDTH = 0.08;
        const BRICK_HEIGHT = 0.04;
        const BRICK_DEPTH = 0.04;
        const BRICK_ROWS = 4;
        const BRICK_COLUMNS = 8;
        
        // Game boundaries
        const GAME_WIDTH = 0.8;
        const GAME_HEIGHT = 0.6;
        const GAME_DEPTH = 0.1;
        
        // Check WebXR support
        if ('xr' in navigator) {
            navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
                if (!supported) {
                    document.getElementById('notSupportedInfo').style.display = 'block';
                    document.getElementById('startARButton').style.display = 'none';
                }
            });
        } else {
            document.getElementById('notSupportedInfo').style.display = 'block';
            document.getElementById('startARButton').style.display = 'none';
        }
        
        // Initialize the scene, camera, and renderer
        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);
            
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
            camera.position.set(0, 1.6, 3);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);
            
            // Set up placement indicator
            createPlacementIndicator();
            
            // Set up AR button
            document.getElementById('startARButton').addEventListener('click', startAR);
            document.getElementById('exitARButton').addEventListener('click', endARSession);
            
            // Add controllers for Meta Quest 3
            setupControllers();
            
            // Create the game elements (will be placed once AR is started and position selected)
            createGameElements();
            gameBoard.visible = false; // Hide until placed
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Set up restart button
            document.getElementById('restartButton').addEventListener('click', restartGame);
            
            // Start animation loop
            renderer.setAnimationLoop(animate);
        }
        
        function createPlacementIndicator() {
            // Create a ring to indicate where the game will be placed
            const geometry = new THREE.RingGeometry(0.15, 0.2, 32);
            geometry.rotateX(-Math.PI / 2);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            placementIndicator = new THREE.Mesh(geometry, material);
            placementIndicator.matrixAutoUpdate = false;
            scene.add(placementIndicator);
            placementIndicator.visible = false;
        }
        
        function setupControllers() {
            // XR Controllers
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart);
            controller1.addEventListener('selectend', onSelectEnd);
            controller1.addEventListener('connected', function(event) {
                this.add(buildController(event.data));
            });
            controller1.addEventListener('disconnected', function() {
                this.remove(this.children[0]);
            });
            scene.add(controller1);
            
            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('selectstart', onSelectStart);
            controller2.addEventListener('selectend', onSelectEnd);
            controller2.addEventListener('connected', function(event) {
                this.add(buildController(event.data));
            });
            controller2.addEventListener('disconnected', function() {
                this.remove(this.children[0]);
            });
            scene.add(controller2);
            
            // The XRControllerModelFactory will automatically fetch controller models
            const controllerModelFactory = new XRControllerModelFactory();
            
            controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            scene.add(controllerGrip1);
            
            controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            scene.add(controllerGrip2);
        }
        
        function buildController(data) {
            let geometry, material;
            
            switch (data.targetRayMode) {
                case 'tracked-pointer':
                    geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, -1], 3));
                    geometry.setAttribute('color', new THREE.Float32BufferAttribute([0.5, 0.5, 0.5, 0, 0, 0], 3));
                    
                    material = new THREE.LineBasicMaterial({
                        vertexColors: true,
                        blending: THREE.AdditiveBlending
                    });
                    
                    return new THREE.Line(geometry, material);
                    
                case 'gaze':
                    geometry = new THREE.RingGeometry(0.02, 0.04, 32).translate(0, 0, -1);
                    material = new THREE.MeshBasicMaterial({
                        opacity: 0.5,
                        transparent: true
                    });
                    return new THREE.Mesh(geometry, material);
            }
        }
        
        function createGameElements() {
            // Create game board
            createGameBoard();
            
            // Create paddle
            createPaddle();
            
            // Create ball
            createBall();
            
            // Create bricks
            createBricks();
        }
        
        function createGameBoard() {
            // Game board container
            gameBoard = new THREE.Group();
            scene.add(gameBoard);
            
            // Position will be set when placed in AR
            gameBoard.position.set(0, 0, -1);
            gameBoard.scale.set(0.5, 0.5, 0.5); // Scale down for AR
            
            // FIX 2: Create BoxLineGeometry correctly
            const boardGeometry = new BoxLineGeometry(
                GAME_WIDTH, GAME_HEIGHT, GAME_DEPTH, 1, 1, 1
            );
            const boardMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
            const boardBox = new THREE.LineSegments(boardGeometry, boardMaterial);
            gameBoard.add(boardBox);
            
            // Create solid back plane for better visibility
            const backPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(GAME_WIDTH, GAME_HEIGHT),
                new THREE.MeshBasicMaterial({ color: 0x000055, opacity: 0.3, transparent: true })
            );
            backPlane.position.z = -GAME_DEPTH/2;
            gameBoard.add(backPlane);
        }
        
        function createPaddle() {
            const paddleGeometry = new THREE.BoxGeometry(PADDLE_WIDTH, PADDLE_HEIGHT, PADDLE_DEPTH);
            const paddleMaterial = new THREE.MeshPhongMaterial({ color: 0x1565c0 });
            paddle = new THREE.Mesh(paddleGeometry, paddleMaterial);
            paddle.position.y = -GAME_HEIGHT/2 + 0.05;
            paddle.position.z = 0;
            gameBoard.add(paddle);
        }
        
        function createBall() {
            const ballGeometry = new THREE.SphereGeometry(BALL_RADIUS, 16, 16);
            const ballMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.position.copy(paddle.position);
            ball.position.y += PADDLE_HEIGHT + BALL_RADIUS;
            gameBoard.add(ball);
        }
        
        function createBricks() {
            const brickGeometry = new THREE.BoxGeometry(BRICK_WIDTH, BRICK_HEIGHT, BRICK_DEPTH);
            
            // Create brick layout
            const brickColors = [0xff0000, 0xff9900, 0xffff00, 0x00ff00, 0x0099ff, 0x9900ff];
            
            const startX = -GAME_WIDTH/2 + BRICK_WIDTH/2 + 0.05;
            const startY = GAME_HEIGHT/2 - BRICK_HEIGHT/2 - 0.05;
            
            for (let row = 0; row < BRICK_ROWS; row++) {
                for (let col = 0; col < BRICK_COLUMNS; col++) {
                    const colorIndex = row % brickColors.length;
                    const brickMaterial = new THREE.MeshPhongMaterial({ color: brickColors[colorIndex] });
                    const brick = new THREE.Mesh(brickGeometry, brickMaterial);
                    
                    brick.position.x = startX + col * (BRICK_WIDTH + 0.01);
                    brick.position.y = startY - row * (BRICK_HEIGHT + 0.01);
                    brick.position.z = 0;
                    
                    gameBoard.add(brick);
                    bricks.push(brick);
                }
            }
        }
        
        function startAR() {
            if (navigator.xr) {
                // FIX 3: Added proper request handling with error catching
                navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['hit-test', 'local-floor'],
                    optionalFeatures: ['dom-overlay'],
                    domOverlay: { root: document.body }
                }).then(onSessionStarted)
                  .catch(error => {
                      console.error('Error starting AR session:', error);
                      document.getElementById('notSupportedInfo').style.display = 'block';
                      document.getElementById('notSupportedInfo').innerHTML = 
                          '<h2>AR Session Error</h2>' +
                          '<p>Could not start AR session: ' + error.message + '</p>' +
                          '<p>Please ensure your device supports WebXR AR.</p>';
                  });
            }
        }
        
        function onSessionStarted(session) {
            session.addEventListener('end', onSessionEnded);
            
            renderer.xr.setReferenceSpaceType('local');
            renderer.xr.setSession(session);
            
            currentSession = session;
            
            document.getElementById('startARButton').style.display = 'none';
            document.getElementById('info').textContent = 'Tap on a surface to place the game';
            
            isGamePlaced = false;
            gameBoard.visible = false;
            placementIndicator.visible = true;
            
            // FIX 4: Reset hit test source request flag
            hitTestSourceRequested = false;
        }
        
        function onSessionEnded() {
            currentSession = null;
            document.getElementById('startARButton').style.display = 'block';
            document.getElementById('info').textContent = 'WebXR AR Breakout Game\nUse Meta Quest 3 controllers to move the paddle and hit the ball';
            document.getElementById('gameOverScreen').style.display = 'none';
            placementIndicator.visible = false;
            gameBoard.visible = false;
            
            // Reset game state
            resetGame();
        }
        
        function endARSession() {
            if (currentSession) {
                currentSession.end();
            }
        }
        
        function resetGame() {
            // Reset game elements
            if (bricks.length > 0) {
                for (const brick of bricks) {
                    gameBoard.remove(brick);
                }
                bricks = [];
            }
            
            // Recreate game elements
            createBricks();
            
            // Reset ball
            ball.position.copy(paddle.position);
            ball.position.y += PADDLE_HEIGHT + BALL_RADIUS;
            ballDirection.set(Math.random() * 0.04 - 0.02, 0.04, 0);
            
            // Reset score and lives
            score = 0;
            lives = 3;
            updateScoreDisplay();
            
            // Reset game state
            gameActive = false;
            gameStarted = false;
            
            // Hide game over screen
            document.getElementById('gameOverScreen').style.display = 'none';
        }
        
        function restartGame() {
            document.getElementById('gameOverScreen').style.display = 'none';
            resetGame();
        }
        
        // FIX 5: Update hit test function with safety checks
        function updateHitTest(frame) {
            if (!isGamePlaced && currentSession) {
                if (!hitTestSourceRequested) {
                    // Request a hit test source
                    currentSession.requestReferenceSpace('viewer')
                        .then((referenceSpace) => {
                            currentSession.requestHitTestSource({ space: referenceSpace })
                                .then((source) => {
                                    hitTestSource = source;
                                })
                                .catch(error => {
                                    console.error('Error requesting hit test source:', error);
                                });
                        })
                        .catch(error => {
                            console.error('Error requesting reference space:', error);
                        });
                    
                    hitTestSourceRequested = true;
                    return;
                }
                
                if (hitTestSource && frame) {
                    try {
                        const hitTestResults = frame.getHitTestResults(hitTestSource);
                        
                        if (hitTestResults && hitTestResults.length > 0) {
                            const hit = hitTestResults[0];
                            
                            if (hit) {
                                // Get hit position
                                const referenceSpace = renderer.xr.getReferenceSpace();
                                if (referenceSpace) {
                                    const pose = hit.getPose(referenceSpace);
                                    
                                    if (pose) {
                                        placementIndicator.visible = true;
                                        placementIndicator.matrix.fromArray(pose.transform.matrix);
                                    }
                                }
                            }
                        } else {
                            placementIndicator.visible = false;
                        }
                    } catch (error) {
                        console.error('Error in hit test:', error);
                    }
                }
            }
        }
        
        // FIX 6: Update place game function with better error handling
        function placeGame(frame) {
            if (!isGamePlaced && currentSession && hitTestSource && frame) {
                try {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    
                    if (hitTestResults && hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        const referenceSpace = renderer.xr.getReferenceSpace();
                        
                        if (referenceSpace) {
                            const pose = hit.getPose(referenceSpace);
                            
                            if (pose) {
                                // Place the game at hit position
                                gameBoard.visible = true;
                                gameBoard.position.set(0, 0, 0);
                                gameBoard.position.setFromMatrixPosition(placementIndicator.matrix);
                                // Adjust height slightly to avoid z-fighting with the floor
                                gameBoard.position.y += 0.05;
                                
                                placementIndicator.visible = false;
                                isGamePlaced = true;
                                document.getElementById('info').textContent = 'Press controller trigger to start the game';
                                
                                // Release the hit test source
                                hitTestSource.cancel();
                                hitTestSource = null;
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error placing game:', error);
                }
            }
        }
        
        function onSelectStart(event) {
            if (!isGamePlaced) {
                // Place the game when the user taps to select
                placeGame(renderer.xr.getFrame());
                return;
            }
            
            // Start the game when controller button is pressed
            const controller = event.target;
            controller.userData.selectPressed = true;
            
            if (isGamePlaced && !gameStarted) {
                gameStarted = true;
                gameActive = true;
                document.getElementById('info').textContent = 'Use controllers to move the paddle';
            }
        }
        
        function onSelectEnd(event) {
            const controller = event.target;
            controller.userData.selectPressed = false;
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function updateScoreDisplay() {
            document.getElementById('scoreDisplay').textContent = `Score: ${score} | Lives: ${lives}`;
        }
        
        function handleGameOver() {
            gameActive = false;
            gameStarted = false;
            document.getElementById('finalScore').textContent = `Your score: ${score}`;
            document.getElementById('gameOverScreen').style.display = 'block';
        }
        
        // FIX 7: Update paddle function with better error handling
        function updatePaddle() {
            if (!isGamePlaced || !gameStarted) return;
            
            // Check if either controller is being used
            const activeController = controller1.userData.selectPressed ? controller1 : 
                                    (controller2.userData.selectPressed ? controller2 : null);
            
            if (activeController) {
                try {
                    // Convert controller position to game board space
                    const controllerWorldPosition = new THREE.Vector3();
                    controllerWorldPosition.setFromMatrixPosition(activeController.matrixWorld);
                    
                    // Transform to local space relative to the game board
                    const localPos = controllerWorldPosition.clone();
                    gameBoard.worldToLocal(localPos);
                    
                    // Update paddle x position, keeping it within bounds
                    paddle.position.x = THREE.MathUtils.clamp(
                        localPos.x,
                        -GAME_WIDTH/2 + PADDLE_WIDTH/2,
                        GAME_WIDTH/2 - PADDLE_WIDTH/2
                    );
                } catch (error) {
                    console.error('Error updating paddle:', error);
                }
            }
        }
        
        // FIX 8: Update ball function with better collision detection
        function updateBall() {
            if (!isGamePlaced || !gameActive || !gameStarted) return;
            
            // FIX: Use clock.getDelta() correctly
            const delta = clock.getDelta();
            const scaledSpeed = ballSpeed * delta * 60; // Scale by 60 to normalize at 60fps
            
            // Move the ball
            ball.position.x += ballDirection.x * scaledSpeed;
            ball.position.y += ballDirection.y * scaledSpeed;
            
            // Check wall collisions
            if (ball.position.x + BALL_RADIUS > GAME_WIDTH/2 || 
                ball.position.x - BALL_RADIUS < -GAME_WIDTH/2) {
                ballDirection.x = -ballDirection.x;
                // Fix ball position if it's outside bounds
                if (ball.position.x + BALL_RADIUS > GAME_WIDTH/2) {
                    ball.position.x = GAME_WIDTH/2 - BALL_RADIUS;
                } else if (ball.position.x - BALL_RADIUS < -GAME_WIDTH/2) {
                    ball.position.x = -GAME_WIDTH/2 + BALL_RADIUS;
                }
            }
            
            if (ball.position.y + BALL_RADIUS > GAME_HEIGHT/2) {
                ballDirection.y = -ballDirection.y;
                // Fix ball position if it's outside bounds
                ball.position.y = GAME_HEIGHT/2 - BALL_RADIUS;
            }
            
            // Check for paddle collision with improved collision detection
            if (ball.position.y - BALL_RADIUS < paddle.position.y + PADDLE_HEIGHT/2 && 
                ball.position.y > paddle.position.y - PADDLE_HEIGHT/2 &&
                ball.position.x > paddle.position.x - PADDLE_WIDTH/2 &&
                ball.position.x < paddle.position.x + PADDLE_WIDTH/2) {
                
                // Calculate rebound angle based on where the ball hit the paddle
                const hitPoint = (ball.position.x - paddle.position.x) / (PADDLE_WIDTH/2);
                ballDirection.x = hitPoint * 0.05;
                ballDirection.y = Math.abs(ballDirection.y);
                
                // Fix ball position to prevent getting stuck in paddle
                ball.position.y = paddle.position.y + PADDLE_HEIGHT/2 + BALL_RADIUS;
                
                // Add a little boost to keep the game moving
                const currentMagnitude = Math.sqrt(ballDirection.x * ballDirection.x + ballDirection.y * ballDirection.y);
                ballDirection.y += 0.001;
                
                // Normalize and scale to maintain consistent speed
                const newMagnitude = Math.sqrt(ballDirection.x * ballDirection.x + ballDirection.y * ballDirection.y);
                ballDirection.x = ballDirection.x * (currentMagnitude / newMagnitude);
                ballDirection.y = ballDirection.y * (currentMagnitude / newMagnitude);
            }
            
            // Check for ball falling out
            if (ball.position.y - BALL_RADIUS < -GAME_HEIGHT/2) {
                lives--;
                updateScoreDisplay();
                
                if (lives <= 0) {
                    handleGameOver();
                } else {
                    // Reset ball
                    ball.position.copy(paddle.position);
                    ball.position.y += PADDLE_HEIGHT + BALL_RADIUS;
                    ballDirection.set(Math.random() * 0.04 - 0.02, 0.04, 0);
                    gameStarted = false;
                    gameActive = false;
                    document.getElementById('info').textContent = 'Press controller trigger to continue';
                }
            }
            
            // Check brick collisions with improved detection
            for (let i = bricks.length - 1; i >= 0; i--) {
                const brick = bricks[i];
                
                // Calculate distance between centers
                const dx = ball.position.x - brick.position.x;
                const dy = ball.position.y - brick.position.y;
                
                // Calculate collision boundaries
                const combinedHalfWidths = BALL_RADIUS + BRICK_WIDTH/2;
                const combinedHalfHeights = BALL_RADIUS + BRICK_HEIGHT/2;
                
                // Check for collision
                if (Math.abs(dx) < combinedHalfWidths && Math.abs(dy) < combinedHalfHeights) {
                    // Determine collision side more accurately
                    const overlapX = combinedHalfWidths - Math.abs(dx);
                    const overlapY = combinedHalfHeights - Math.abs(dy);
                    
                    if (overlapX < overlapY) {
                        // Left/right collision
                        ballDirection.x = -ballDirection.x;
                        
                        // Fix ball position to prevent getting stuck in brick
                        if (dx > 0) {
                            ball.position.x = brick.position.x + BRICK_WIDTH/2 + BALL_RADIUS;
                        } else {
                            ball.position.x = brick.position.x - BRICK_WIDTH/2 - BALL_RADIUS;
                        }
                    } else {
                        // Top/bottom collision
                        ballDirection.y = -ballDirection.y;
                        
                        // Fix ball position to prevent getting stuck in brick
                        if (dy > 0) {
                            ball.position.y = brick.position.y + BRICK_HEIGHT/2 + BALL_RADIUS;
                        } else {
                            ball.position.y = brick.position.y - BRICK_HEIGHT/2 - BALL_RADIUS;
                        }
                    }
                    
                    // Remove the brick
                    gameBoard.remove(brick);
                    bricks.splice(i, 1);
                    
                    // Update score
                    score += 10;
                    updateScoreDisplay();
                    
                    // Check if all bricks are cleared
                    if (bricks.length === 0) {
                        // Victory!
                        score += lives * 50; // Bonus for remaining lives
                        updateScoreDisplay();
                        handleGameOver();
                    }
                    
                    // Only handle one brick collision per frame
                    break;
                }
            }
        }
        
        function animate() {
            const frame = renderer.xr.getFrame();
            
            // Update hit test and placement in AR
            if (frame && !isGamePlaced) {
                updateHitTest(frame);
            }
            
            // Update game elements
            if (isGamePlaced) {
                updatePaddle();
                updateBall();
            }
            
            // Render the scene
            renderer.render(scene, camera);
        }
        
        // Initialize the application
        init();
    </script>
</body>
</html>
